package pythagorean

import "math"


// For the Range() function, we use the euclid method to generate the triplets.
// 1. All Primitives Pythagorean Triplets can be generated with {m^2-n^2, 2mn, m^2+n2}
// using the euclid method, as long as m > n, m and n are coprimes, and at least
// one of m or n is even.
// 2. The other Pythagorean Triplets can be derived from a Primitive Triplet by
// multiplying all of its elements by k (k > 1).
// We can find all the Triplets by combining the primitives and non-primitives triplets.
// Note that we can't just generate the primitives triplets using a min constraints, since
// any of the solution can be generated by a triplet with first element min/k (k > 1) so
// we need to generate the primitives with a min of 3 (the 'a' for the smallest valid
// triplet) and then filter out the multiple triplets under the min.

// For the Sum() function, we loop on the 'a' values under sum/3, then the b values
// under sum/2 and check which one are pythagorean triplets. This is faster than
// using a 3rd nested loop.

type Triplet [3]int

func (t Triplet) mult(k int) Triplet {
	return Triplet{k * t[0], k * t[1], k * t[2]}
}

func gcd(a, b int) int {
	if a > b {
		a, b = b, a
	}
	if a == 0 {
		return b
	}
	return gcd(b%a, a)
}

func areCoprimes(a, b int) bool {
	return gcd(a, b) == 1
}

func areBothOdd(a, b int) bool {
	return a%2 == 1 && b%2 == 1
}

func isPythagorean(a, b, c int) bool {
	return a*a+b*b == c*c
}

func euclid(m, n, k int) Triplet {
	a := m*m - n*n
	b := 2 * m * n
	c := m*m + n*n
    // Make sure the triplet elements are in ascending order.
	if a > b {
		a, b = b, a
	}
	return Triplet{k * a, k * b, k * c}
}

// Primitive generates all Primitives Pythagorean triplets with larger element
// less or equal to max.
func primitive(max int) []Triplet {
	var res []Triplet
	for m := 2; m < int(math.Sqrt(float64(max))); m++ {
		for n := 1; n < m; n++ {
			if !areCoprimes(m, n) || areBothOdd(m, n) {
				continue
			}
			tr := euclid(m, n, 1)
			if tr[2] > max {
				continue
			}
			res = append(res, tr)
		}
	}
	return res
}

// Extend takes a list of primitive triplets and add all the
// 'multiple' triplets for which the largest element is less or equal to max.
func extend(max int, triplets []Triplet) []Triplet{
    // By definition of the Primitive Pythagorean Triplets, we don't have to
    // worry about duplicates.
    nprim := len(triplets)
	for i:= 0; i < nprim; i++ {
		for k := 2; ; k++ {
			ktr := triplets[i].mult(k)
			if ktr[2] > max {
				break
			}
            triplets = append(triplets, ktr)
		}
	}
	return triplets
}

// Filter filters out the triplet where the first element is less than min.
func filter(min int, triplets []Triplet) []Triplet {
	var res []Triplet
	for _, tr := range triplets {
		if tr[0] >= min {
			res = append(res, tr)
		}
	}
	return res
}

// Range generates list of all Pythagorean triplets with side lengths
// in the provided range.
func Range(min, max int) []Triplet {
    res := primitive(max)
	res = extend(max, res)
	return filter(min, res)
}


// Sum returns a list of all Pythagorean triplets with a certain perimeter.
func Sum(p int) []Triplet {
	var res []Triplet
	for a := 3; a < p/3; a++ {
		for b := a + 1; b < p/2; b++ {
			c := p - a - b
			if isPythagorean(a, b, c) {
				res = append(res, Triplet{a, b, c})
			}
		}
	}
	return res
}
